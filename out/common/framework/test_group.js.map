{"version":3,"sources":["../../../src/common/framework/test_group.ts"],"names":["extractPublicParams","publicParamsEquals","kPathSeparator","stringifyPublicParams","validQueryPart","assert","makeTestGroup","fixture","TestGroup","makeTestGroupForUnitTesting","constructor","Set","iterate","test","tests","checkName","name","decodeURIComponent","seen","has","add","parts","split","p","TestBuilder","push","checkCaseNamesAndDuplicates","testPath","undefined","fn","testFn","cases","testcase","testcaseString","some","x","params","casesIterable","Array","from","RunCaseSpecific","id","run","rec","start","inst","init","finalize","ex","threw","finish"],"mappings":"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","sourcesContent":["import { Fixture } from './fixture.js';\nimport { TestCaseRecorder } from './logging/test_case_recorder.js';\nimport {\n  CaseParams,\n  CaseParamsIterable,\n  extractPublicParams,\n  publicParamsEquals,\n} from './params_utils.js';\nimport { kPathSeparator } from './query/separators.js';\nimport { stringifyPublicParams } from './query/stringify_params.js';\nimport { validQueryPart } from './query/validQueryPart.js';\nimport { assert } from './util/util.js';\n\nexport type RunFn = (rec: TestCaseRecorder) => Promise<void>;\n\nexport interface TestCaseID {\n  readonly test: readonly string[];\n  readonly params: CaseParams;\n}\n\nexport interface RunCase {\n  readonly id: TestCaseID;\n  run: RunFn;\n}\n\n// Interface for defining tests\nexport interface TestGroupBuilder<F extends Fixture> {\n  test(name: string): TestBuilderWithName<F, never>;\n}\nexport function makeTestGroup<F extends Fixture>(fixture: FixtureClass<F>): TestGroupBuilder<F> {\n  return new TestGroup(fixture);\n}\n\n// Interface for running tests\nexport interface RunCaseIterable {\n  iterate(): Iterable<RunCase>;\n  checkCaseNamesAndDuplicates(): void;\n}\nexport function makeTestGroupForUnitTesting<F extends Fixture>(\n  fixture: FixtureClass<F>\n): TestGroup<F> {\n  return new TestGroup(fixture);\n}\n\ntype FixtureClass<F extends Fixture> = new (log: TestCaseRecorder, params: CaseParams) => F;\ntype TestFn<F extends Fixture, P extends {}> = (t: F & { params: P }) => Promise<void> | void;\n\nclass TestGroup<F extends Fixture> implements RunCaseIterable, TestGroupBuilder<F> {\n  private fixture: FixtureClass<F>;\n  private seen: Set<string> = new Set();\n  private tests: Array<TestBuilder<F, never>> = [];\n\n  constructor(fixture: FixtureClass<F>) {\n    this.fixture = fixture;\n  }\n\n  *iterate(): Iterable<RunCase> {\n    for (const test of this.tests) {\n      yield* test.iterate();\n    }\n  }\n\n  private checkName(name: string): void {\n    assert(\n      // Shouldn't happen due to the rule above. Just makes sure that treated\n      // unencoded strings as encoded strings is OK.\n      name === decodeURIComponent(name),\n      `Not decodeURIComponent-idempotent: ${name} !== ${decodeURIComponent(name)}`\n    );\n    assert(!this.seen.has(name), `Duplicate test name: ${name}`);\n\n    this.seen.add(name);\n  }\n\n  // TODO: This could take a fixture, too, to override the one for the group.\n  test(name: string): TestBuilderWithName<F, never> {\n    this.checkName(name);\n\n    const parts = name.split(kPathSeparator);\n    for (const p of parts) {\n      assert(validQueryPart.test(p), `Invalid test name part ${p}; must match ${validQueryPart}`);\n    }\n\n    const test = new TestBuilder<F, never>(parts, this.fixture);\n    this.tests.push(test);\n    return test;\n  }\n\n  checkCaseNamesAndDuplicates(): void {\n    for (const test of this.tests) {\n      test.checkCaseNamesAndDuplicates();\n    }\n  }\n}\n\ninterface TestBuilderWithName<F extends Fixture, P extends {}> extends TestBuilderWithParams<F, P> {\n  params<NewP extends {}>(specs: Iterable<NewP>): TestBuilderWithParams<F, NewP>;\n}\n\ninterface TestBuilderWithParams<F extends Fixture, P extends {}> {\n  fn(fn: TestFn<F, P>): void;\n}\n\nclass TestBuilder<F extends Fixture, P extends {}> {\n  private readonly testPath: string[];\n  private readonly fixture: FixtureClass<F>;\n  private testFn: TestFn<F, P> | undefined;\n  private cases?: CaseParamsIterable = undefined;\n\n  constructor(testPath: string[], fixture: FixtureClass<F>) {\n    this.testPath = testPath;\n    this.fixture = fixture;\n  }\n\n  fn(fn: TestFn<F, P>): void {\n    this.testFn = fn;\n  }\n\n  checkCaseNamesAndDuplicates(): void {\n    if (this.cases === undefined) {\n      return;\n    }\n\n    // This is n^2.\n    const seen: CaseParams[] = [];\n    for (const testcase of this.cases) {\n      // stringifyPublicParams also checks for invalid params values\n      const testcaseString = stringifyPublicParams(testcase);\n      assert(\n        !seen.some(x => publicParamsEquals(x, testcase)),\n        `Duplicate public test case params: ${testcaseString}`\n      );\n      seen.push(testcase);\n    }\n  }\n\n  params<NewP extends {}>(casesIterable: Iterable<NewP>): TestBuilderWithParams<F, NewP> {\n    assert(this.cases === undefined, 'test case is already parameterized');\n    this.cases = Array.from(casesIterable);\n\n    return (this as unknown) as TestBuilderWithParams<F, NewP>;\n  }\n\n  *iterate(): IterableIterator<RunCase> {\n    assert(this.testFn !== undefined, 'No test function (.fn()) for test');\n    for (const params of this.cases || [{}]) {\n      yield new RunCaseSpecific(this.testPath, params, this.fixture, this.testFn);\n    }\n  }\n}\n\nclass RunCaseSpecific<F extends Fixture> implements RunCase {\n  readonly id: TestCaseID;\n\n  private readonly params: CaseParams | null;\n  private readonly fixture: FixtureClass<F>;\n  private readonly fn: TestFn<F, never>;\n\n  constructor(\n    testPath: string[],\n    params: CaseParams,\n    fixture: FixtureClass<F>,\n    fn: TestFn<F, never>\n  ) {\n    this.id = { test: testPath, params: extractPublicParams(params) };\n    this.params = params;\n    this.fixture = fixture;\n    this.fn = fn;\n  }\n\n  async run(rec: TestCaseRecorder): Promise<void> {\n    rec.start();\n    try {\n      const inst = new this.fixture(rec, this.params || {});\n\n      try {\n        await inst.init();\n        /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n        await this.fn(inst as any);\n      } finally {\n        // Runs as long as constructor succeeded, even if initialization or the test failed.\n        await inst.finalize();\n      }\n    } catch (ex) {\n      // There was an exception from constructor, init, test, or finalize.\n      // An error from init or test may have been a SkipTestCase.\n      // An error from finalize may have been an eventualAsyncExpectation failure\n      // or unexpected validation/OOM error from the GPUDevice.\n      rec.threw(ex);\n    }\n    rec.finish();\n  }\n}\n"],"file":"test_group.js"}