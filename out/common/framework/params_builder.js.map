{"version":3,"sources":["../../../src/common/framework/params_builder.ts"],"names":["publicParamsEquals","assert","typeAssert","poptions","name","values","iter","makeReusableIterable","value","pbool","params","ParamsBuilder","Symbol","iterator","paramSpecs","combine","newParams","a","b","mergeParams","expand","expander","filter","pred","p","unless","x","exclude","excludeArray","Array","from","every","e","generatorFn","key","Object","keys"],"mappings":"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","sourcesContent":["import { CaseParams, CaseParamsIterable, publicParamsEquals } from './params_utils.js';\nimport { assert } from './util/util.js';\n\n/** Forces a type to resolve its type definitions, to make it readable/debuggable. */\nexport type ResolveType<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: ResolveType<O[K]> }\n    : never\n  : T;\n\n/**\n * Computes the intersection of a set of types, given the union of those types.\n *\n * From: https://stackoverflow.com/a/56375136\n */\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void\n  ? I\n  : never;\n\n/** Conditionally chooses between two types depending on whether T is a union. */\ntype CheckForUnion<T, TErr, TOk> = [T] extends [UnionToIntersection<T>] ? TOk : TErr;\n\n/** Conditionally chooses a type (or void) depending on whether T is a string. */\ntype CheckForStringLiteralType<T, TOk> = string extends T ? void : CheckForUnion<T, void, TOk>;\n\ntype KeyOfNeverable<T> = T extends never ? never : keyof T;\ntype AllKeysFromUnion<T> = keyof T | KeyOfNeverable<UnionToIntersection<T>>;\ntype KeyOfOr<T, K, Default> = K extends keyof T ? T[K] : Default;\n\n/**\n * Flatten a union of interfaces into a single interface encoding the same type.\n *\n * Flattens a union in such a way that:\n * `{ a: number, b?: undefined } | { b: string, a?: undefined }`\n * (which is the value type of `[{ a: 1 }, { b: 1 }]`)\n * becomes `{ a: number | undefined, b: string | undefined }`.\n *\n * And also works for `{ a: number } | { b: string }` which maps to the same.\n */\ntype FlattenUnionOfInterfaces<T> = {\n  [K in AllKeysFromUnion<T>]: KeyOfOr<\n    T,\n    // If T always has K, just take T[K] (union of C[K] for each component C of T):\n    K,\n    // Otherwise, take the union of C[K] for each component C of T, PLUS undefined:\n    undefined | KeyOfOr<UnionToIntersection<T>, K, void>\n  >;\n};\n\nfunction typeAssert<T extends 'pass'>() {}\n{\n  type Test<T, U> = [T] extends [U]\n    ? [U] extends [T]\n      ? 'pass'\n      : { actual: ResolveType<T>; expected: U }\n    : { actual: ResolveType<T>; expected: U };\n\n  type T01 = { a: number } | { b: string };\n  type T02 = { a: number } | { b?: string };\n  type T03 = { a: number } | { a?: number };\n  type T04 = { a: number } | { a: string };\n  type T05 = { a: number } | { a?: string };\n\n  type T11 = { a: number; b?: undefined } | { a?: undefined; b: string };\n\n  type T21 = { a: number; b?: undefined } | { b: string };\n  type T22 = { a: number; b?: undefined } | { b?: string };\n  type T23 = { a: number; b?: undefined } | { a?: number };\n  type T24 = { a: number; b?: undefined } | { a: string };\n  type T25 = { a: number; b?: undefined } | { a?: string };\n  type T26 = { a: number; b?: undefined } | { a: undefined };\n  type T27 = { a: number; b?: undefined } | { a: undefined; b: undefined };\n\n  /* prettier-ignore */ {\n    typeAssert<Test<FlattenUnionOfInterfaces<T01>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T02>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T03>, { a: number | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T04>, { a: number | string }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T05>, { a: number | string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T11>, { a: number | undefined; b: string | undefined }>>();\n\n    typeAssert<Test<FlattenUnionOfInterfaces<T22>, { a: number | undefined; b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T23>, { a: number | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T24>, { a: number | string; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T25>, { a: number | string | undefined; b: undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T27>, { a: number | undefined; b: undefined }>>();\n\n    // Unexpected test results - hopefully okay to ignore these\n    typeAssert<Test<FlattenUnionOfInterfaces<T21>, { b: string | undefined }>>();\n    typeAssert<Test<FlattenUnionOfInterfaces<T26>, { a: number | undefined }>>();\n  }\n}\n\nexport function poptions<Name extends string, V>(\n  name: Name,\n  values: Iterable<V>\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: V }>> {\n  const iter = makeReusableIterable(function* () {\n    for (const value of values) {\n      yield { [name]: value };\n    }\n  });\n  /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n  return iter as any;\n}\n\nexport function pbool<Name extends string>(\n  name: Name\n): CheckForStringLiteralType<Name, Iterable<{ [name in Name]: boolean }>> {\n  return poptions(name, [false, true]);\n}\n\nexport function params(): ParamsBuilder<{}> {\n  return new ParamsBuilder();\n}\n\nexport class ParamsBuilder<A extends {}> implements CaseParamsIterable {\n  private paramSpecs: CaseParamsIterable = [{}];\n\n  [Symbol.iterator](): Iterator<A> {\n    const iter: Iterator<CaseParams> = this.paramSpecs[Symbol.iterator]();\n    return iter as Iterator<A>;\n  }\n\n  combine<B extends {}>(newParams: Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of newParams) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  expand<B extends {}>(expander: (_: A) => Iterable<B>): ParamsBuilder<Merged<A, B>> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const a of paramSpecs) {\n        for (const b of expander(a)) {\n          yield mergeParams(a, b);\n        }\n      }\n    }) as CaseParamsIterable;\n    /* eslint-disable-next-line @typescript-eslint/no-explicit-any */\n    return this as any;\n  }\n\n  filter(pred: (_: A) => boolean): ParamsBuilder<A> {\n    const paramSpecs = this.paramSpecs as Iterable<A>;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (pred(p)) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n\n  unless(pred: (_: A) => boolean): ParamsBuilder<A> {\n    return this.filter(x => !pred(x));\n  }\n\n  exclude(exclude: CaseParamsIterable): ParamsBuilder<A> {\n    const excludeArray = Array.from(exclude);\n    const paramSpecs = this.paramSpecs;\n    this.paramSpecs = makeReusableIterable(function* () {\n      for (const p of paramSpecs) {\n        if (excludeArray.every(e => !publicParamsEquals(p, e))) {\n          yield p;\n        }\n      }\n    });\n    return this;\n  }\n}\n\n// If you create an Iterable by calling a generator function (e.g. in IIFE), it is exhausted after\n// one use. This just wraps a generator function in an object so it be iterated multiple times.\nfunction makeReusableIterable<P>(generatorFn: () => Generator<P>): Iterable<P> {\n  return { [Symbol.iterator]: generatorFn };\n}\n\ntype ValueTypeForKeyOfMergedType<A, B, Key extends keyof A | keyof B> = Key extends keyof A\n  ? Key extends keyof B\n    ? void // Key is in both types\n    : A[Key] // Key is only in A\n  : Key extends keyof B\n  ? B[Key] // Key is only in B\n  : void; // Key is in neither type (not possible)\n\ntype Merged<A, B> = MergedFromFlat<A, FlattenUnionOfInterfaces<B>>;\ntype MergedFromFlat<A, B> = keyof A & keyof B extends never\n  ? string extends keyof A | keyof B\n    ? never // (keyof A | keyof B) == string, which is too broad\n    : {\n        [Key in keyof A | keyof B]: ValueTypeForKeyOfMergedType<A, B, Key>;\n      }\n  : never; // (keyof A & keyof B) is not empty, so they overlapped\n\nfunction mergeParams<A extends {}, B extends {}>(a: A, b: B): Merged<A, B> {\n  for (const key of Object.keys(a)) {\n    assert(!(key in b), 'Duplicate key: ' + key);\n  }\n  return { ...a, ...b } as Merged<A, B>;\n}\n"],"file":"params_builder.js"}