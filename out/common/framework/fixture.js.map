{"version":3,"sources":["../../../src/common/framework/fixture.ts"],"names":["assert","SkipTestCase","Error","Fixture","constructor","rec","params","init","debug","msg","skip","finalize","numOutstandingAsyncExpectations","Promise","all","eventualExpectations","warn","fail","expectationFailed","immediateAsyncExpectation","fn","ret","eventualAsyncExpectation","promise","push","expectErrorValue","expectedName","ex","niceStack","message","actualName","name","shouldResolve","p","m","shouldReject","shouldThrow","expect","cond"],"mappings":";;6MAEA,SAASA,MAAT,QAAuB,gBAAvB;;AAEA,OAAO,MAAMC,YAAN,SAA2BC,KAA3B,CAAiC;;AAExC;AACA;AACA;AACA,OAAO,MAAMC,OAAN,CAAc;;;;;;AAMnBC,EAAAA,WAAW,CAACC,GAAD,EAAwBC,MAAxB,EAA4C,4HAHC,EAGD,2DAFb,CAEa;AACrD,SAAKD,GAAL,GAAWA,GAAX;AACA,SAAKC,MAAL,GAAcA,MAAd;AACD;;AAED;AACA;AACA,QAAMC,IAAN,GAA4B,CAAE;;AAE9BC,EAAAA,KAAK,CAACC,GAAD,EAAoB;AACvB,SAAKJ,GAAL,CAASG,KAAT,CAAe,IAAIN,KAAJ,CAAUO,GAAV,CAAf;AACD;;AAEDC,EAAAA,IAAI,CAACD,GAAD,EAAqB;AACvB,UAAM,IAAIR,YAAJ,CAAiBQ,GAAjB,CAAN;AACD;;AAED,QAAME,QAAN,GAAgC;AAC9BX,IAAAA,MAAM;AACJ,SAAKY,+BAAL,KAAyC,CADrC;AAEJ,iGAFI,CAAN;;AAIA,UAAMC,OAAO,CAACC,GAAR,CAAY,KAAKC,oBAAjB,CAAN;AACD;;AAEDC,EAAAA,IAAI,CAACP,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASW,IAAT,CAAc,IAAId,KAAJ,CAAUO,GAAV,CAAd;AACD;;AAEDQ,EAAAA,IAAI,CAACR,GAAD,EAAqB;AACvB,SAAKJ,GAAL,CAASa,iBAAT,CAA2B,IAAIhB,KAAJ,CAAUO,GAAV,CAA3B;AACD;;AAED,QAAgBU,yBAAhB,CAA6CC,EAA7C,EAA+E;AAC7E,SAAKR,+BAAL;AACA,UAAMS,GAAG,GAAG,MAAMD,EAAE,EAApB;AACA,SAAKR,+BAAL;AACA,WAAOS,GAAP;AACD;;AAESC,EAAAA,wBAAV,CAAsCF,EAAtC,EAAwF;AACtF,UAAMG,OAAO,GAAGH,EAAE,CAAC,IAAIlB,KAAJ,EAAD,CAAlB;AACA,SAAKa,oBAAL,CAA0BS,IAA1B,CAA+BD,OAA/B;AACA,WAAOA,OAAP;AACD;;AAEOE,EAAAA,gBAAR,CAAyBC,YAAzB,EAA+CC,EAA/C,EAA4DC,SAA5D,EAAoF;AAClF,QAAI,EAAED,EAAE,YAAYzB,KAAhB,CAAJ,EAA4B;AAC1B0B,MAAAA,SAAS,CAACC,OAAV,GAAqB,kCAAiC,OAAOF,EAAG,KAAIA,EAAG,EAAvE;AACA,WAAKtB,GAAL,CAASa,iBAAT,CAA2BU,SAA3B;AACA;AACD;AACD,UAAME,UAAU,GAAGH,EAAE,CAACI,IAAtB;AACA,QAAID,UAAU,KAAKJ,YAAnB,EAAiC;AAC/BE,MAAAA,SAAS,CAACC,OAAV,GAAqB,SAAQC,UAAW,gBAAeJ,YAAa,KAAIC,EAAG,EAA3E;AACA,WAAKtB,GAAL,CAASa,iBAAT,CAA2BU,SAA3B;AACD,KAHD,MAGO;AACLA,MAAAA,SAAS,CAACC,OAAV,GAAqB,aAAYC,UAAW,GAAEH,EAAE,CAACE,OAAQ,EAAzD;AACA,WAAKxB,GAAL,CAASG,KAAT,CAAeoB,SAAf;AACD;AACF;;AAEDI,EAAAA,aAAa,CAACC,CAAD,EAAsBxB,GAAtB,EAA0C;AACrD,SAAKa,wBAAL,CAA8B,MAAMM,SAAN,IAAmB;AAC/C,YAAMM,CAAC,GAAGzB,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,UAAI;AACF,cAAMwB,CAAN;AACAL,QAAAA,SAAS,CAACC,OAAV,GAAoB,yBAAyBK,CAA7C;AACD,OAHD,CAGE,OAAOP,EAAP,EAAW;AACXC,QAAAA,SAAS,CAACC,OAAV,GAAqB,WAAUK,CAAE,KAAIP,EAAE,CAACE,OAAQ,EAAhD;AACA,aAAKxB,GAAL,CAASa,iBAAT,CAA2BU,SAA3B;AACD;AACF,KATD;AAUD;;AAEDO,EAAAA,YAAY,CAACT,YAAD,EAAuBO,CAAvB,EAA4CxB,GAA5C,EAAgE;AAC1E,SAAKa,wBAAL,CAA8B,MAAMM,SAAN,IAAmB;AAC/C,YAAMM,CAAC,GAAGzB,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,UAAI;AACF,cAAMwB,CAAN;AACAL,QAAAA,SAAS,CAACC,OAAV,GAAoB,mBAAmBK,CAAvC;AACA,aAAK7B,GAAL,CAASa,iBAAT,CAA2BU,SAA3B;AACD,OAJD,CAIE,OAAOD,EAAP,EAAW;AACXC,QAAAA,SAAS,CAACC,OAAV,GAAoB,yBAAyBK,CAA7C;AACA,aAAKT,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwCC,SAAxC;AACD;AACF,KAVD;AAWD;;AAEDQ,EAAAA,WAAW,CAACV,YAAD,EAAuBN,EAAvB,EAAuCX,GAAvC,EAA2D;AACpE,UAAMyB,CAAC,GAAGzB,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,QAAI;AACFW,MAAAA,EAAE;AACF,WAAKf,GAAL,CAASa,iBAAT,CAA2B,IAAIhB,KAAJ,CAAU,kBAAkBgC,CAA5B,CAA3B;AACD,KAHD,CAGE,OAAOP,EAAP,EAAW;AACX,WAAKF,gBAAL,CAAsBC,YAAtB,EAAoCC,EAApC,EAAwC,IAAIzB,KAAJ,CAAUgC,CAAV,CAAxC;AACD;AACF;;AAEDG,EAAAA,MAAM,CAACC,IAAD,EAAgB7B,GAAhB,EAAuC;AAC3C,QAAI6B,IAAJ,EAAU;AACR,YAAMJ,CAAC,GAAGzB,GAAG,GAAG,OAAOA,GAAV,GAAgB,EAA7B;AACA,WAAKJ,GAAL,CAASG,KAAT,CAAe,IAAIN,KAAJ,CAAU,cAAcgC,CAAxB,CAAf;AACD,KAHD,MAGO;AACL,WAAK7B,GAAL,CAASa,iBAAT,CAA2B,IAAIhB,KAAJ,CAAUO,GAAV,CAA3B;AACD;AACD,WAAO6B,IAAP;AACD,GAjHkB","sourcesContent":["import { TestCaseRecorder } from './logging/test_case_recorder.js';\nimport { CaseParams } from './params_utils.js';\nimport { assert } from './util/util.js';\n\nexport class SkipTestCase extends Error {}\n\n// A Fixture is a class used to instantiate each test case at run time.\n// A new instance of the Fixture is created for every single test case\n// (i.e. every time the test function is run).\nexport class Fixture {\n  params: unknown;\n  protected rec: TestCaseRecorder;\n  private eventualExpectations: Array<Promise<unknown>> = [];\n  private numOutstandingAsyncExpectations = 0;\n\n  constructor(rec: TestCaseRecorder, params: CaseParams) {\n    this.rec = rec;\n    this.params = params;\n  }\n\n  // This has to be a member function instead of an async `createFixture` function, because\n  // we need to be able to ergonomically override it in subclasses.\n  async init(): Promise<void> {}\n\n  debug(msg: string): void {\n    this.rec.debug(new Error(msg));\n  }\n\n  skip(msg: string): never {\n    throw new SkipTestCase(msg);\n  }\n\n  async finalize(): Promise<void> {\n    assert(\n      this.numOutstandingAsyncExpectations === 0,\n      'there were outstanding asynchronous expectations (e.g. shouldReject) at the end of the test'\n    );\n    await Promise.all(this.eventualExpectations);\n  }\n\n  warn(msg?: string): void {\n    this.rec.warn(new Error(msg));\n  }\n\n  fail(msg?: string): void {\n    this.rec.expectationFailed(new Error(msg));\n  }\n\n  protected async immediateAsyncExpectation<T>(fn: () => Promise<T>): Promise<T> {\n    this.numOutstandingAsyncExpectations++;\n    const ret = await fn();\n    this.numOutstandingAsyncExpectations--;\n    return ret;\n  }\n\n  protected eventualAsyncExpectation<T>(fn: (niceStack: Error) => Promise<T>): Promise<T> {\n    const promise = fn(new Error());\n    this.eventualExpectations.push(promise);\n    return promise;\n  }\n\n  private expectErrorValue(expectedName: string, ex: unknown, niceStack: Error): void {\n    if (!(ex instanceof Error)) {\n      niceStack.message = `THREW non-error value, of type ${typeof ex}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n      return;\n    }\n    const actualName = ex.name;\n    if (actualName !== expectedName) {\n      niceStack.message = `THREW ${actualName}, instead of ${expectedName}: ${ex}`;\n      this.rec.expectationFailed(niceStack);\n    } else {\n      niceStack.message = `OK: threw ${actualName}${ex.message}`;\n      this.rec.debug(niceStack);\n    }\n  }\n\n  shouldResolve(p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'resolved as expected' + m;\n      } catch (ex) {\n        niceStack.message = `REJECTED${m}\\n${ex.message}`;\n        this.rec.expectationFailed(niceStack);\n      }\n    });\n  }\n\n  shouldReject(expectedName: string, p: Promise<unknown>, msg?: string): void {\n    this.eventualAsyncExpectation(async niceStack => {\n      const m = msg ? ': ' + msg : '';\n      try {\n        await p;\n        niceStack.message = 'DID NOT REJECT' + m;\n        this.rec.expectationFailed(niceStack);\n      } catch (ex) {\n        niceStack.message = 'rejected as expected' + m;\n        this.expectErrorValue(expectedName, ex, niceStack);\n      }\n    });\n  }\n\n  shouldThrow(expectedName: string, fn: () => void, msg?: string): void {\n    const m = msg ? ': ' + msg : '';\n    try {\n      fn();\n      this.rec.expectationFailed(new Error('DID NOT THROW' + m));\n    } catch (ex) {\n      this.expectErrorValue(expectedName, ex, new Error(m));\n    }\n  }\n\n  expect(cond: boolean, msg?: string): boolean {\n    if (cond) {\n      const m = msg ? ': ' + msg : '';\n      this.rec.debug(new Error('expect OK' + m));\n    } else {\n      this.rec.expectationFailed(new Error(msg));\n    }\n    return cond;\n  }\n}\n"],"file":"fixture.js"}