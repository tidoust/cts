{"version":3,"sources":["../../../../src/common/framework/gpu/device_pool.ts"],"names":["assert","raceWithRejectOnTimeout","unreachable","assertReject","getGPU","TestFailedButDeviceReusable","Error","TestOOMedShouldAttemptGC","kPopErrorScopeTimeoutMS","DevicePool","undefined","acquire","failed","holder","makeHolder","ex","acquired","beginErrorScopes","device","release","endErrorScopes","lostReason","gpu","adapter","requestAdapter","requestDevice","lost","then","ev","message","pushErrorScope","gpuValidationError","gpuOutOfMemoryError","popErrorScope","GPUValidationError","GPUOutOfMemoryError"],"mappings":"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","sourcesContent":["import { assert, raceWithRejectOnTimeout, unreachable, assertReject } from '../util/util.js';\n\nimport { getGPU } from './implementation.js';\n\ninterface DeviceHolder {\n  acquired: boolean; // whether the device is currently in use by a test\n  device: GPUDevice;\n  lostReason?: string; // initially undefined; becomes set when the device is lost\n}\n\nclass TestFailedButDeviceReusable extends Error {}\nexport class TestOOMedShouldAttemptGC extends Error {}\n\nconst kPopErrorScopeTimeoutMS = 5000;\n\nexport class DevicePool {\n  failed: boolean = false; // if device init failed once, never try again\n  holder?: DeviceHolder = undefined; // undefined if \"uninitialized\" (not yet initialized, or lost)\n\n  async acquire(): Promise<GPUDevice> {\n    assert(!this.failed, 'WebGPU device previously failed to initialize; not retrying');\n\n    if (this.holder === undefined) {\n      try {\n        this.holder = await DevicePool.makeHolder();\n      } catch (ex) {\n        this.failed = true;\n        throw ex;\n      }\n    }\n    assert(!this.holder.acquired, 'Device was in use on DevicePool.acquire');\n    this.holder.acquired = true;\n\n    this.beginErrorScopes();\n    return this.holder.device;\n  }\n\n  // When a test is done using a device, it's released back into the pool.\n  // This waits for error scopes, checks their results, and checks for various error conditions.\n  async release(device: GPUDevice): Promise<void> {\n    const holder = this.holder;\n    assert(holder !== undefined, 'trying to release a device while pool is uninitialized');\n    assert(holder.acquired, 'trying to release a device while already released');\n    assert(device === holder.device, 'Released device was the wrong device');\n\n    try {\n      // Time out if popErrorScope never completes. This could happen due to a browser bug - e.g.,\n      // as of this writing, on Chrome GPU process crash, popErrorScope just hangs.\n      await raceWithRejectOnTimeout(\n        this.endErrorScopes(),\n        kPopErrorScopeTimeoutMS,\n        'finalization popErrorScope timed out'\n      );\n\n      // (Hopefully if the device was lost, it has been reported by the time endErrorScopes()\n      // has finished (or timed out). If not, it could cause a finite number of extra test\n      // failures following this one (but should recover eventually).)\n      const lostReason = holder.lostReason;\n      if (lostReason !== undefined) {\n        // Fail the current test.\n        unreachable(`Device was lost: ${lostReason}`);\n      }\n    } catch (ex) {\n      // Any error that isn't explicitly TestFailedButDeviceReusable forces a new device to be\n      // created for the next test.\n      if (!(ex instanceof TestFailedButDeviceReusable)) {\n        this.holder = undefined;\n      }\n      throw ex;\n    } finally {\n      // TODO: device.destroy()\n\n      // Mark the holder as free. (This only has an effect if the pool still has the holder.)\n      // This could be done at the top but is done here to guard against async-races during release.\n      holder.acquired = false;\n    }\n  }\n\n  // Gets a device and creates a DeviceHolder.\n  // If the device is lost, DeviceHolder.lostReason gets set.\n  private static async makeHolder(): Promise<DeviceHolder> {\n    const gpu = getGPU();\n    const adapter = await gpu.requestAdapter();\n    assert(adapter !== null);\n    const device = await adapter.requestDevice();\n    assert(device !== null);\n\n    const holder: DeviceHolder = {\n      acquired: false,\n      device,\n      lostReason: undefined,\n    };\n    holder.device.lost.then(ev => {\n      holder.lostReason = ev.message;\n    });\n    return holder;\n  }\n\n  // Create error scopes that wrap the entire test.\n  private beginErrorScopes(): void {\n    assert(this.holder !== undefined);\n    this.holder.device.pushErrorScope('out-of-memory');\n    this.holder.device.pushErrorScope('validation');\n  }\n\n  // End the whole-test error scopes. Check that there are no extra error scopes, and that no\n  // otherwise-uncaptured errors occurred during the test.\n  private async endErrorScopes(): Promise<void> {\n    assert(this.holder !== undefined);\n    let gpuValidationError: GPUValidationError | GPUOutOfMemoryError | null;\n    let gpuOutOfMemoryError: GPUValidationError | GPUOutOfMemoryError | null;\n\n    try {\n      // May reject if the device was lost.\n      gpuValidationError = await this.holder.device.popErrorScope();\n      gpuOutOfMemoryError = await this.holder.device.popErrorScope();\n    } catch (ex) {\n      assert(\n        this.holder.lostReason !== undefined,\n        \"popErrorScope failed, but device.lost hasn't fired (yet)\"\n      );\n      throw ex;\n    }\n\n    await assertReject(\n      this.holder.device.popErrorScope(),\n      'There was an extra error scope on the stack after a test'\n    );\n\n    if (gpuValidationError !== null) {\n      assert(gpuValidationError instanceof GPUValidationError);\n      // Allow the device to be reused.\n      throw new TestFailedButDeviceReusable(\n        `Unexpected validation error occurred: ${gpuValidationError.message}`\n      );\n    }\n    if (gpuOutOfMemoryError !== null) {\n      assert(gpuOutOfMemoryError instanceof GPUOutOfMemoryError);\n      // Don't allow the device to be reused; unexpected OOM could break the device.\n      throw new TestOOMedShouldAttemptGC('Unexpected out-of-memory error occurred');\n    }\n  }\n}\n"],"file":"device_pool.js"}