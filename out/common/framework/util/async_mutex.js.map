{"version":3,"sources":["../../../../src/common/framework/util/async_mutex.ts"],"names":["AsyncMutex","with","fn","p","newestQueueItem"],"mappings":";;6MAAA,OAAO,MAAMA,UAAN,CAAiB;;;AAKtB;AACA;AACA,QAAMC,IAAN,CAAcC,EAAd,EAAgD;AAC9C,UAAMC,CAAC,GAAG,CAAC,YAAY;AACrB;AACA;AACA,UAAI,KAAKC,eAAT,EAA0B;AACxB,cAAM,KAAKA,eAAX;AACD;AACD,aAAOF,EAAE,EAAT;AACD,KAPS,GAAV;;AASA;AACA,SAAKE,eAAL,GAAuBD,CAAvB;AACA;AACA,WAAOA,CAAP;AACD,GArBqB","sourcesContent":["export class AsyncMutex {\n  // The newest item currently waiting for the mutex. This promise is chained so\n  // that it implicitly defines a FIFO queue where this is the \"last-in\" item.\n  private newestQueueItem: Promise<unknown> | undefined;\n\n  // Run an async function with a lock on this mutex.\n  // Waits until the mutex is available, locks it, runs the function, then releases it.\n  async with<T>(fn: () => Promise<T>): Promise<T> {\n    const p = (async () => {\n      // If the mutex is locked, wait for the last thing in the queue before running.\n      // (Everything in the queue runs in order, so this is after everything currently enqueued.)\n      if (this.newestQueueItem) {\n        await this.newestQueueItem;\n      }\n      return fn();\n    })();\n\n    // Push the newly-created Promise onto the queue by replacing the old \"newest\" item.\n    this.newestQueueItem = p;\n    // And return so the caller can wait on the result.\n    return p;\n  }\n}\n"],"file":"async_mutex.js"}