{"version":3,"sources":["../../../../../src/webgpu/api/validation/copy_between_linear_data_and_texture/copyBetweenLinearDataAndTexture_dataRelated.spec.ts"],"names":["description","params","poptions","makeTestGroup","kUncompressedTextureFormatInfo","kSizedTextureFormats","kSizedTextureFormatInfo","align","CopyBetweenLinearDataAndTextureTest","kAllTestMethods","texelBlockAlignmentTestExpanderForOffset","texelBlockAlignmentTestExpanderForRowsPerImage","formatCopyableWithMethod","g","test","combine","fn","t","rowsPerImageInBlocks","copyHeightInBlocks","copyDepth","method","format","rowsPerImage","blockHeight","copyHeight","texture","device","createTexture","size","width","height","depth","usage","GPUTextureUsage","COPY_SRC","COPY_DST","success","testRun","bytesPerRow","dataSize","_success","bytesPerRowPadding","rowsPerImagePaddingInBlocks","copyWidthInBlocks","offsetInBlocks","filter","bytesPerRowAlignment","info","copyWidth","blockWidth","offset","bytesPerBlock","bytesInACompleteRow","minDataSize","requiredBytesInCopy","createAlignedTexture","expand","blocksPerRow","additionalPaddingPerRow","dataSizeInBlocks"],"mappings":"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","sourcesContent":["export const description = '';\n\nimport { params, poptions } from '../../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../../common/framework/test_group.js';\nimport {\n  kUncompressedTextureFormatInfo,\n  kSizedTextureFormats,\n  kSizedTextureFormatInfo,\n} from '../../../capability_info.js';\nimport { align } from '../../../util/math.js';\n\nimport {\n  CopyBetweenLinearDataAndTextureTest,\n  kAllTestMethods,\n  texelBlockAlignmentTestExpanderForOffset,\n  texelBlockAlignmentTestExpanderForRowsPerImage,\n  formatCopyableWithMethod,\n} from './copyBetweenLinearDataAndTexture.js';\n\nexport const g = makeTestGroup(CopyBetweenLinearDataAndTextureTest);\n\ng.test('bound_on_rows_per_image')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine(poptions('rowsPerImageInBlocks', [0, 1, 2]))\n      .combine(poptions('copyHeightInBlocks', [0, 1, 2]))\n      .combine(poptions('copyDepth', [1, 3]))\n  )\n  .fn(async t => {\n    const { rowsPerImageInBlocks, copyHeightInBlocks, copyDepth, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const rowsPerImage = rowsPerImageInBlocks * kUncompressedTextureFormatInfo[format].blockHeight;\n    const copyHeight = copyHeightInBlocks * kUncompressedTextureFormatInfo[format].blockHeight;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depth: 3 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    // The WebGPU spec:\n    // If layout.rowsPerImage is not 0, it must be greater than or equal to copyExtent.height.\n    // If copyExtent.depth is greater than 1: layout.rowsPerImage must be greater than or equal to copyExtent.height.\n    // TODO: Update this if https://github.com/gpuweb/gpuweb/issues/984 changes the spec.\n\n    let success = true;\n    if (rowsPerImage !== 0 && rowsPerImage < copyHeight) {\n      success = false;\n    }\n    if (copyDepth > 1 && rowsPerImage < copyHeight) {\n      success = false;\n    }\n\n    t.testRun(\n      { texture },\n      { bytesPerRow: 1024, rowsPerImage },\n      { width: 0, height: copyHeight, depth: copyDepth },\n      { dataSize: 1, method, success }\n    );\n  });\n\n// Test with offset + requiredBytesIsCopy overflowing GPUSize64.\ng.test('offset_plus_required_bytes_in_copy_overflow')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine([\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depth: 1, _success: true }, // success case\n        { bytesPerRow: 2 ** 31, rowsPerImage: 2 ** 31, depth: 16, _success: false }, // bytesPerRow * rowsPerImage * (depth - 1) overflows.\n      ])\n  )\n  .fn(async t => {\n    const { method, bytesPerRow, rowsPerImage, depth, _success } = t.params;\n\n    const texture = t.device.createTexture({\n      size: [1, 1, depth],\n      format: 'rgba8unorm',\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    t.testRun(\n      { texture },\n      { bytesPerRow, rowsPerImage },\n      { width: 1, height: 1, depth },\n      {\n        dataSize: 10000,\n        method,\n        success: _success,\n      }\n    );\n  });\n\n// Testing that the minimal data size condition is checked correctly.\n// In the success case, we test the exact value.\n// In the failing case, we test the exact value minus 1.\ng.test('required_bytes_in_copy')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine([\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 0 }, // no padding\n        { bytesPerRowPadding: 0, rowsPerImagePaddingInBlocks: 6 }, // rowsPerImage padding\n        { bytesPerRowPadding: 6, rowsPerImagePaddingInBlocks: 0 }, // bytesPerRow padding\n        { bytesPerRowPadding: 15, rowsPerImagePaddingInBlocks: 17 }, // both paddings\n      ])\n      .combine([\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // standard copy\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 3, offsetInBlocks: 11 }, // standard copy, offset > 0\n        { copyWidthInBlocks: 256, copyHeightInBlocks: 3, copyDepth: 2, offsetInBlocks: 0 }, // copyWidth is 256-aligned\n        { copyWidthInBlocks: 0, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of width\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 0, copyDepth: 5, offsetInBlocks: 0 }, // empty copy because of height\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 4, copyDepth: 0, offsetInBlocks: 13 }, // empty copy because of depth, offset > 0\n        { copyWidthInBlocks: 1, copyHeightInBlocks: 4, copyDepth: 5, offsetInBlocks: 0 }, // copyWidth = 1\n        { copyWidthInBlocks: 3, copyHeightInBlocks: 1, copyDepth: 5, offsetInBlocks: 15 }, // copyHeight = 1, offset > 0\n        { copyWidthInBlocks: 5, copyHeightInBlocks: 4, copyDepth: 1, offsetInBlocks: 0 }, // copyDepth = 1\n        { copyWidthInBlocks: 7, copyHeightInBlocks: 1, copyDepth: 1, offsetInBlocks: 0 }, // copyHeight = 1 and copyDepth = 1\n      ])\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .fn(async t => {\n    const {\n      offsetInBlocks,\n      bytesPerRowPadding,\n      rowsPerImagePaddingInBlocks,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      method,\n    } = t.params;\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we align the bytesInACompleteRow value and multiply\n    // bytesPerRowPadding by 256.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n\n    const info = kSizedTextureFormatInfo[format];\n    const copyWidth = copyWidthInBlocks * info.blockWidth;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const offset = offsetInBlocks * info.bytesPerBlock;\n    const rowsPerImage = copyHeight + rowsPerImagePaddingInBlocks * info.blockHeight;\n    const bytesPerRow =\n      align(t.bytesInACompleteRow(copyWidth, format), bytesPerRowAlignment) +\n      bytesPerRowPadding * bytesPerRowAlignment;\n    const size = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const minDataSize =\n      offset + t.requiredBytesInCopy({ offset, bytesPerRow, rowsPerImage }, format, size);\n\n    const texture = t.createAlignedTexture(format, size);\n\n    t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, size, {\n      dataSize: minDataSize,\n      method,\n      success: true,\n    });\n\n    if (minDataSize > 0) {\n      t.testRun({ texture }, { offset, bytesPerRow, rowsPerImage }, size, {\n        dataSize: minDataSize - 1,\n        method,\n        success: false,\n      });\n    }\n  });\n\ng.test('texel_block_alignment_on_rows_per_image')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n      .expand(texelBlockAlignmentTestExpanderForRowsPerImage)\n  )\n  .fn(async t => {\n    const { rowsPerImage, format, method } = t.params;\n    const size = { width: 0, height: 0, depth: 0 };\n\n    const texture = t.createAlignedTexture(format, size);\n\n    const success = rowsPerImage % kSizedTextureFormatInfo[format].blockHeight! === 0;\n\n    t.testRun({ texture }, { bytesPerRow: 0, rowsPerImage }, size, {\n      dataSize: 1,\n      method,\n      success,\n    });\n  });\n\n// TODO: Update this if https://github.com/gpuweb/gpuweb/issues/985 changes the spec.\ng.test('texel_block_alignment_on_offset')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n      .expand(texelBlockAlignmentTestExpanderForOffset)\n  )\n  .fn(async t => {\n    const { format, offset, method } = t.params;\n    const size = { width: 0, height: 0, depth: 0 };\n\n    const texture = t.createAlignedTexture(format, size);\n\n    const success = offset % kSizedTextureFormatInfo[format].bytesPerBlock! === 0;\n\n    t.testRun({ texture }, { offset, bytesPerRow: 0 }, size, { dataSize: offset, method, success });\n  });\n\ng.test('bound_on_bytes_per_row')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine([\n        { blocksPerRow: 2, additionalPaddingPerRow: 0, copyWidthInBlocks: 2 }, // success\n        { blocksPerRow: 2, additionalPaddingPerRow: 5, copyWidthInBlocks: 3 }, // success if bytesPerBlock <= 5\n        { blocksPerRow: 1, additionalPaddingPerRow: 0, copyWidthInBlocks: 2 }, // failure, bytesPerRow > 0\n        { blocksPerRow: 0, additionalPaddingPerRow: 0, copyWidthInBlocks: 1 }, // failure, bytesPerRow = 0\n      ])\n      .combine([\n        { copyHeightInBlocks: 0, copyDepth: 1 }, // we don't have to check the bound\n        { copyHeightInBlocks: 1, copyDepth: 0 }, // we don't have to check the bound\n        { copyHeightInBlocks: 2, copyDepth: 1 }, // we have to check the bound\n        { copyHeightInBlocks: 0, copyDepth: 2 }, // we have to check the bound\n      ])\n      .combine(poptions('format', kSizedTextureFormats))\n      .filter(formatCopyableWithMethod)\n  )\n  .fn(async t => {\n    const {\n      blocksPerRow,\n      additionalPaddingPerRow,\n      copyWidthInBlocks,\n      copyHeightInBlocks,\n      copyDepth,\n      format,\n      method,\n    } = t.params;\n\n    // In the CopyB2T and CopyT2B cases we need to have bytesPerRow 256-aligned,\n    // to make this happen we multiply copyWidth and bytesPerRow by 256, so that\n    // the appropriate inequalities still hold.\n    const bytesPerRowAlignment = method === 'WriteTexture' ? 1 : 256;\n\n    const info = kSizedTextureFormatInfo[format];\n    const copyWidth = copyWidthInBlocks * info.blockWidth * bytesPerRowAlignment;\n    const copyHeight = copyHeightInBlocks * info.blockHeight;\n    const bytesPerRow =\n      (blocksPerRow * info.bytesPerBlock + additionalPaddingPerRow) * bytesPerRowAlignment;\n    const size = { width: copyWidth, height: copyHeight, depth: copyDepth };\n\n    const texture = t.createAlignedTexture(format, size);\n\n    let success = true;\n    if (copyHeight > 1 || copyDepth > 1) {\n      success = bytesPerRow >= t.bytesInACompleteRow(copyWidth, format);\n    }\n\n    t.testRun({ texture }, { bytesPerRow, rowsPerImage: copyHeight }, size, {\n      dataSize: 1024,\n      method,\n      success,\n    });\n  });\n\ng.test('bound_on_offset')\n  .params(\n    params()\n      .combine(poptions('method', kAllTestMethods))\n      .combine(poptions('offsetInBlocks', [0, 1, 2]))\n      .combine(poptions('dataSizeInBlocks', [0, 1, 2]))\n  )\n  .fn(async t => {\n    const { offsetInBlocks, dataSizeInBlocks, method } = t.params;\n\n    const format = 'rgba8unorm';\n    const info = kSizedTextureFormatInfo[format];\n    const offset = offsetInBlocks * info.bytesPerBlock!;\n    const dataSize = dataSizeInBlocks * info.bytesPerBlock!;\n\n    const texture = t.device.createTexture({\n      size: { width: 4, height: 4, depth: 1 },\n      format,\n      usage: GPUTextureUsage.COPY_SRC | GPUTextureUsage.COPY_DST,\n    });\n\n    const success = offset <= dataSize;\n\n    t.testRun(\n      { texture },\n      { offset, bytesPerRow: 0 },\n      { width: 0, height: 0, depth: 0 },\n      { dataSize, method, success }\n    );\n  });\n"],"file":"copyBetweenLinearDataAndTexture_dataRelated.spec.js"}