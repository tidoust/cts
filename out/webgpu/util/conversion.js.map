{"version":3,"sources":["../../../src/webgpu/util/conversion.ts"],"names":["assert","floatAsNormalizedInteger","float","bits","signed","max","Math","pow","round","float32ToFloatBits","n","signBits","exponentBits","fractionBits","bias","Number","isFinite","buf","DataView","ArrayBuffer","Float32Array","BYTES_PER_ELEMENT","setFloat32","getUint32","fractionBitsToDiscard","sign","exp","newBiasedExp","newFraction","assertInIntegerRange","min","gammaCompress"],"mappings":"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","sourcesContent":["import { assert } from '../../common/framework/util/util.js';\n\nexport function floatAsNormalizedInteger(float: number, bits: number, signed: boolean): number {\n  if (signed) {\n    assert(float >= -1 && float <= 1);\n    const max = Math.pow(2, bits - 1) - 1;\n    return Math.round(float * max);\n  } else {\n    assert(float >= 0 && float <= 1);\n    const max = Math.pow(2, bits) - 1;\n    return Math.round(float * max);\n  }\n}\n\n// Does not handle clamping, underflow, overflow, denormalized numbers\nexport function float32ToFloatBits(\n  n: number,\n  signBits: 0 | 1,\n  exponentBits: number,\n  fractionBits: number,\n  bias: number\n): number {\n  assert(exponentBits <= 8);\n  assert(fractionBits <= 23);\n  assert(Number.isFinite(n));\n\n  if (n === 0) {\n    return 0;\n  }\n\n  if (signBits === 0) {\n    assert(n >= 0);\n  }\n\n  const buf = new DataView(new ArrayBuffer(Float32Array.BYTES_PER_ELEMENT));\n  buf.setFloat32(0, n, true);\n  const bits = buf.getUint32(0, true);\n  // bits (32): seeeeeeeefffffffffffffffffffffff\n\n  const fractionBitsToDiscard = 23 - fractionBits;\n\n  // 0 or 1\n  const sign = (bits >> 31) & signBits;\n\n  // >> to remove fraction, & to remove sign, - 127 to remove bias.\n  const exp = ((bits >> 23) & 0xff) - 127;\n\n  // Convert to the new biased exponent.\n  const newBiasedExp = bias + exp;\n  assert(newBiasedExp >= 0 && newBiasedExp < 1 << exponentBits);\n\n  // Mask only the fraction, and discard the lower bits.\n  const newFraction = (bits & 0x7fffff) >> fractionBitsToDiscard;\n  return (sign << (exponentBits + fractionBits)) | (newBiasedExp << fractionBits) | newFraction;\n}\n\nexport function assertInIntegerRange(n: number, bits: number, signed: boolean): void {\n  if (signed) {\n    const min = -Math.pow(2, bits - 1);\n    const max = Math.pow(2, bits - 1) - 1;\n    assert(n >= min && n <= max);\n  } else {\n    const max = Math.pow(2, bits) - 1;\n    assert(n >= 0 && n <= max);\n  }\n}\n\nexport function gammaCompress(n: number): number {\n  n = n <= 0.0031308 ? 12.92 * n : 1.055 * Math.pow(n, 1 / 2.4) - 0.055;\n  return n < 0 ? 0 : n > 1 ? 1 : n;\n}\n"],"file":"conversion.js"}