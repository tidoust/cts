{"version":3,"sources":["../../../../src/webgpu/util/texture/layout.ts"],"names":["assert","unreachable","kSizedTextureFormatInfo","align","isAligned","kBytesPerRowAlignment","kBufferCopyAlignment","kDefaultLayoutOptions","mipLevel","bytesPerRow","undefined","rowsPerImage","getMipSizePassthroughLayers","dimension","size","shiftMinOne","n","Math","max","getTextureCopyLayout","format","options","mipSize","blockWidth","blockHeight","bytesPerBlock","minBytesPerRow","alignedMinBytesPerRow","bytesPerSlice","sliceSize","byteLength","fillTextureDataWithTexelValue","texelValue","outputBuffer","texelValueBytes","Uint8Array","outputTexelValueBytes","slice","row","col","byteOffset","set","createTextureUploadBuffer","device","buffer","createBuffer","mappedAtCreation","usage","GPUBufferUsage","COPY_SRC","mapping","getMappedRange","unmap"],"mappings":"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","sourcesContent":["import { assert, unreachable } from '../../../common/framework/util/util.js';\nimport { kSizedTextureFormatInfo, SizedTextureFormat } from '../../capability_info.js';\nimport { align, isAligned } from '../math.js';\n\nexport const kBytesPerRowAlignment = 256;\nexport const kBufferCopyAlignment = 4;\n\nexport interface LayoutOptions {\n  mipLevel: number;\n  bytesPerRow?: number;\n  rowsPerImage?: number;\n}\n\nconst kDefaultLayoutOptions = { mipLevel: 0, bytesPerRow: undefined, rowsPerImage: undefined };\n\nexport function getMipSizePassthroughLayers(\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  mipLevel: number\n): [number, number, number] {\n  const shiftMinOne = (n: number) => Math.max(1, n >> mipLevel);\n  switch (dimension) {\n    case '1d':\n      assert(size[2] === 1);\n      return [shiftMinOne(size[0]), size[1], size[2]];\n    case '2d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), size[2]];\n    case '3d':\n      return [shiftMinOne(size[0]), shiftMinOne(size[1]), shiftMinOne(size[2])];\n    default:\n      unreachable();\n  }\n}\n\nexport function getTextureCopyLayout(\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  bytesPerBlock: number;\n  byteLength: number;\n  minBytesPerRow: number;\n  bytesPerRow: number;\n  rowsPerImage: number;\n  mipSize: [number, number, number];\n} {\n  const { mipLevel } = options;\n  let { bytesPerRow, rowsPerImage } = options;\n\n  const mipSize = getMipSizePassthroughLayers(dimension, size, mipLevel);\n\n  const { blockWidth, blockHeight, bytesPerBlock } = kSizedTextureFormatInfo[format];\n\n  assert(isAligned(mipSize[0], blockWidth));\n  const minBytesPerRow = (mipSize[0] / blockWidth) * bytesPerBlock;\n  const alignedMinBytesPerRow = align(minBytesPerRow, kBytesPerRowAlignment);\n  if (bytesPerRow !== undefined) {\n    assert(bytesPerRow >= alignedMinBytesPerRow);\n    assert(isAligned(bytesPerRow, kBytesPerRowAlignment));\n  } else {\n    bytesPerRow = alignedMinBytesPerRow;\n  }\n\n  if (rowsPerImage !== undefined) {\n    assert(rowsPerImage >= mipSize[1]);\n  } else {\n    rowsPerImage = mipSize[1];\n  }\n\n  assert(isAligned(rowsPerImage, blockHeight));\n  const bytesPerSlice = bytesPerRow * (rowsPerImage / blockHeight);\n  const sliceSize =\n    bytesPerRow * (mipSize[1] / blockHeight - 1) + bytesPerBlock * (mipSize[0] / blockWidth);\n  const byteLength = bytesPerSlice * (mipSize[2] - 1) + sliceSize;\n\n  return {\n    bytesPerBlock,\n    byteLength: align(byteLength, kBufferCopyAlignment),\n    minBytesPerRow,\n    bytesPerRow,\n    rowsPerImage,\n    mipSize,\n  };\n}\n\nexport function fillTextureDataWithTexelValue(\n  texelValue: ArrayBuffer,\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  outputBuffer: ArrayBuffer,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): void {\n  const { blockWidth, blockHeight, bytesPerBlock } = kSizedTextureFormatInfo[format];\n  assert(bytesPerBlock === texelValue.byteLength);\n\n  const { byteLength, rowsPerImage, bytesPerRow } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  assert(byteLength <= outputBuffer.byteLength);\n\n  const mipSize = getMipSizePassthroughLayers(dimension, size, options.mipLevel);\n\n  const texelValueBytes = new Uint8Array(texelValue);\n  const outputTexelValueBytes = new Uint8Array(outputBuffer);\n  for (let slice = 0; slice < mipSize[2]; ++slice) {\n    for (let row = 0; row < mipSize[1]; row += blockHeight) {\n      for (let col = 0; col < mipSize[0]; col += blockWidth) {\n        const byteOffset =\n          slice * rowsPerImage * bytesPerRow + row * bytesPerRow + col * texelValue.byteLength;\n        outputTexelValueBytes.set(texelValueBytes, byteOffset);\n      }\n    }\n  }\n}\n\nexport function createTextureUploadBuffer(\n  texelValue: ArrayBuffer,\n  device: GPUDevice,\n  format: SizedTextureFormat,\n  dimension: GPUTextureDimension,\n  size: [number, number, number],\n  options: LayoutOptions = kDefaultLayoutOptions\n): {\n  buffer: GPUBuffer;\n  bytesPerRow: number;\n  rowsPerImage: number;\n} {\n  const { byteLength, bytesPerRow, rowsPerImage, bytesPerBlock } = getTextureCopyLayout(\n    format,\n    dimension,\n    size,\n    options\n  );\n\n  const buffer = device.createBuffer({\n    mappedAtCreation: true,\n    size: byteLength,\n    usage: GPUBufferUsage.COPY_SRC,\n  });\n  const mapping = buffer.getMappedRange();\n\n  assert(texelValue.byteLength === bytesPerBlock);\n  fillTextureDataWithTexelValue(texelValue, format, dimension, mapping, size, options);\n  buffer.unmap();\n\n  return {\n    buffer,\n    bytesPerRow,\n    rowsPerImage,\n  };\n}\n"],"file":"layout.js"}